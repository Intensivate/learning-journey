
in the June 2017 version of Rocket Chip.  This revision: 
https://github.com/freechipsproject/rocket-chip/tree/1f18a37f01f1034b501a7f4c2edaaffb292d7186
In / src / main / scala / rocket / RocketTiles.scala

There is a bunch of conversion code, that builds up Resources from the parameters passed in to RocketTile:

```scala
val cpuDevice = new Device {
   def describe(resources: ResourceBindings): Description = {
     val block =  p(CacheBlockBytes)
     val m = if (rocketParams.core.mulDiv.nonEmpty) "m" else ""
     val a = if (rocketParams.core.useAtomics) "a" else ""
     val f = if (rocketParams.core.fpu.nonEmpty) "f" else ""
...
  ResourceBinding {
   Resource(cpuDevice, "reg").bind(ResourceInt(BigInt(hartid)))
   Resource(intcDevice, "reg").bind(ResourceInt(BigInt(hartid)))

   intNode.edgesIn.flatMap(_.source.sources).map { case s =>
     for (i <- s.range.start until s.range.end) {
      csrIntMap.lift(i).foreach { j =>
         s.resources.foreach { r =>
           r.bind(intcDevice, ResourceInt(j))
         }
       }
     }
   }
 }
```

Each TileLink slave has a device type, and set of request types. These are captured in plain english in the resources.  ResourceBinding is a dedicated class to make it easier to find these properties during elaboration or while the graph of lazymodules is being generated.  It also generates the device tree (machine configuration string used by Linux kernel).  For an example, search for "sifive-blocks"

When modifying what goes inside a RocketTile, if the ResourceBinding gets out of synch, then it will not break Tilelink as long as you conform to Tilelink requirements like non-overlapping address regions and other assertions set up in `TLMonitor`.  It will also not break Diplomacy because, in general, the parameters given to tilelink get automatically inserted into "resource" stuff.

One place to be careful with Resource things is in the Linux kernel -- it relies on the machine configuration string, which is generated by Resource.

